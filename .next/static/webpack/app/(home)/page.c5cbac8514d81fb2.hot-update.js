"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(home)/page",{

/***/ "(app-pages-browser)/./src/components/page-ui/heroCanvas.js":
/*!**********************************************!*\
  !*** ./src/components/page-ui/heroCanvas.js ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\nconst canvasDots = function() {\n    if (typeof document === \"undefined\") {\n        return;\n    }\n    const canvas = document.querySelector(\"canvas\"), ctx = canvas.getContext(\"2d\"), colorDot = [\n        \"rgb(255, 1, 1)\",\n        \"rgb(255, 1, 1)\",\n        \"rgb(255, 1, 1)\",\n        \"rgb(1, 255, 1)\",\n        \"rgb(1, 255, 1)\"\n    ], color = \"rgb(255, 1, 1)\";\n    // ctx.globalAlpha = 0.8;\n    canvas.width = document.body.scrollWidth;\n    canvas.height = window.innerHeight;\n    canvas.style.display = \"block\";\n    // ctx.fillStyle = colorDot;\n    // ctx.fillStyle = 'hsl(' + 360 * Math.random() + ', 50%, 50%)';\n    ctx.lineWidth = 0.3;\n    ctx.strokeStyle = color;\n    let mousePosition = {\n        x: 30 * canvas.width / 100,\n        y: 30 * canvas.height / 100\n    };\n    const windowSize = window.innerWidth;\n    let dots;\n    if (windowSize > 1600) {\n        dots = {\n            nb: 1000,\n            distance: 70,\n            d_radius: 300,\n            array: []\n        };\n    } else if (windowSize > 1300) {\n        dots = {\n            nb: 575,\n            distance: 60,\n            d_radius: 280,\n            array: []\n        };\n    } else if (windowSize > 1100) {\n        dots = {\n            nb: 500,\n            distance: 55,\n            d_radius: 250,\n            array: []\n        };\n    } else if (windowSize > 800) {\n        dots = {\n            nb: 300,\n            distance: 0,\n            d_radius: 0,\n            array: []\n        };\n    } else if (windowSize > 600) {\n        dots = {\n            nb: 200,\n            distance: 0,\n            d_radius: 0,\n            array: []\n        };\n    } else {\n        dots = {\n            nb: 100,\n            distance: 0,\n            d_radius: 0,\n            array: []\n        };\n    }\n    // decided to turn off connecting dots under 1100px\n    // } else if (windowSize > 650) {\n    //   dots = {\n    //     nb: 400,\n    //     distance: 50,\n    //     d_radius: 185,\n    //     array: [],\n    //   };\n    // } else if (windowSize > 500) {\n    //   dots = {\n    //     nb: 325,\n    //     distance: 45,\n    //     d_radius: 170,\n    //     array: [],\n    //   };\n    // } else {\n    //   dots = {\n    //     nb: 270,\n    //     distance: 45,\n    //     d_radius: 140,\n    //     array: [],\n    //   };\n    // }\n    function Dot() {\n        this.x = Math.random() * canvas.width;\n        this.y = Math.random() * canvas.height;\n        this.vx = -0.5 + Math.random();\n        this.vy = -0.5 + Math.random();\n        this.radius = Math.random() * 1.5;\n        // this.colour = 'hsl(' + 360 * Math.random() + ', 50%, 50%)';\n        this.colour = colorDot[Math.floor(Math.random() * colorDot.length)];\n    }\n    Dot.prototype = {\n        create: function() {\n            ctx.beginPath();\n            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);\n            // ctx.fillStyle = this.colour;\n            // make the dot colour fade out the further they are from the mouse\n            const dotDistance = ((this.x - mousePosition.x) ** 2 + (this.y - mousePosition.y) ** 2) ** 0.5;\n            const distanceRatio = dotDistance / (windowSize / 1.7);\n            // this chops the bracket off the rgb colour and ads an opacity\n            ctx.fillStyle = this.colour.slice(0, -1) + \",\".concat(1 - distanceRatio, \")\");\n            ctx.fill();\n        },\n        animate: function() {\n            // dont animate the first dot, it will follow mouse\n            for(let i = 1; i < dots.nb; i++){\n                const dot = dots.array[i];\n                if (dot.y < 0 || dot.y > canvas.height) {\n                    dot.vx = dot.vx;\n                    dot.vy = -dot.vy;\n                } else if (dot.x < 0 || dot.x > canvas.width) {\n                    dot.vx = -dot.vx;\n                    dot.vy = dot.vy;\n                }\n                dot.x += dot.vx;\n                dot.y += dot.vy;\n            }\n        },\n        line: function() {\n            for(let i = 0; i < dots.nb; i++){\n                for(let j = 0; j < dots.nb; j++){\n                    const i_dot = dots.array[i];\n                    const j_dot = dots.array[j];\n                    if (i_dot.x - j_dot.x < dots.distance && i_dot.y - j_dot.y < dots.distance && i_dot.x - j_dot.x > -dots.distance && i_dot.y - j_dot.y > -dots.distance) {\n                        if (i_dot.x - mousePosition.x < dots.d_radius && i_dot.y - mousePosition.y < dots.d_radius && i_dot.x - mousePosition.x > -dots.d_radius && i_dot.y - mousePosition.y > -dots.d_radius) {\n                            ctx.beginPath();\n                            ctx.moveTo(i_dot.x, i_dot.y);\n                            ctx.lineTo(j_dot.x, j_dot.y);\n                            // make the fill colour fade out the further you are from the mouse\n                            const dotDistance = ((i_dot.x - mousePosition.x) ** 2 + (i_dot.y - mousePosition.y) ** 2) ** 0.5;\n                            let distanceRatio = dotDistance / dots.d_radius;\n                            // make it so it doesnt fade out completely\n                            distanceRatio -= 0.3;\n                            if (distanceRatio < 0) {\n                                distanceRatio = 0;\n                            }\n                            ctx.strokeStyle = \"rgb(255, 0, 0, \".concat(1 - distanceRatio, \")\");\n                            ctx.stroke();\n                            ctx.closePath();\n                        }\n                    }\n                }\n            }\n        }\n    };\n    function createDots() {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        for(let i = 0; i < dots.nb; i++){\n            dots.array.push(new Dot());\n            var dot = dots.array[i];\n            dot.create();\n        }\n        // first dot to be relativley large\n        dots.array[0].radius = 1.5;\n        // first dot to be blue\n        dots.array[0].colour = \"#51a2e9\";\n        dot.line();\n        dot.animate();\n    }\n    window.onmousemove = function(parameter) {\n        mousePosition.x = parameter.pageX;\n        mousePosition.y = parameter.pageY;\n        // sometimes if the mouse is off screen on refresh, it bugs out\n        try {\n            // want the first dot to follow the mouse\n            dots.array[0].x = parameter.pageX;\n            dots.array[0].y = parameter.pageY;\n        } catch (e) {\n        //\n        }\n    };\n    mousePosition.x = window.innerWidth / 2;\n    mousePosition.y = window.innerHeight / 2;\n    const draw = setInterval(createDots, 1000 / 30);\n    window.onresize = function() {\n        clearInterval(draw);\n        canvasDots();\n    // console.log(yippe);\n    };\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (canvasDots);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3BhZ2UtdWkvaGVyb0NhbnZhcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTUEsYUFBYTtJQUNqQixJQUFHLE9BQU9DLGFBQWEsYUFBWTtRQUNqQztJQUNGO0lBQ0EsTUFBTUMsU0FBU0QsU0FBU0UsYUFBYSxDQUFDLFdBQ3BDQyxNQUFNRixPQUFPRyxVQUFVLENBQUMsT0FDeEJDLFdBQVc7UUFDVDtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0QsRUFDREMsUUFBUTtJQUVWLHlCQUF5QjtJQUN6QkwsT0FBT00sS0FBSyxHQUFHUCxTQUFTUSxJQUFJLENBQUNDLFdBQVc7SUFDeENSLE9BQU9TLE1BQU0sR0FBR0MsT0FBT0MsV0FBVztJQUNsQ1gsT0FBT1ksS0FBSyxDQUFDQyxPQUFPLEdBQUc7SUFDdkIsNEJBQTRCO0lBQzVCLGdFQUFnRTtJQUNoRVgsSUFBSVksU0FBUyxHQUFHO0lBQ2hCWixJQUFJYSxXQUFXLEdBQUdWO0lBRWxCLElBQUlXLGdCQUFnQjtRQUNsQkMsR0FBRyxLQUFNakIsT0FBT00sS0FBSyxHQUFJO1FBQ3pCWSxHQUFHLEtBQU1sQixPQUFPUyxNQUFNLEdBQUk7SUFDNUI7SUFFQSxNQUFNVSxhQUFhVCxPQUFPVSxVQUFVO0lBQ3BDLElBQUlDO0lBRUosSUFBSUYsYUFBYSxNQUFNO1FBQ3JCRSxPQUFPO1lBQ0xDLElBQUk7WUFDSkMsVUFBVTtZQUNWQyxVQUFVO1lBQ1ZDLE9BQU8sRUFBRTtRQUNYO0lBQ0YsT0FBTyxJQUFJTixhQUFhLE1BQU07UUFDNUJFLE9BQU87WUFDTEMsSUFBSTtZQUNKQyxVQUFVO1lBQ1ZDLFVBQVU7WUFDVkMsT0FBTyxFQUFFO1FBQ1g7SUFDRixPQUFPLElBQUlOLGFBQWEsTUFBTTtRQUM1QkUsT0FBTztZQUNMQyxJQUFJO1lBQ0pDLFVBQVU7WUFDVkMsVUFBVTtZQUNWQyxPQUFPLEVBQUU7UUFDWDtJQUNGLE9BQU8sSUFBSU4sYUFBYSxLQUFLO1FBQzNC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LFVBQVVFLEtBQUs7UUFFakMsK0RBQStEO1FBQy9ELElBQUk7WUFDRix5Q0FBeUM7WUFDekN6QyxLQUFLSSxLQUFLLENBQUMsRUFBRSxDQUFDUixDQUFDLEdBQUcyQyxVQUFVQyxLQUFLO1lBQ2pDeEMsS0FBS0ksS0FBSyxDQUFDLEVBQUUsQ0FBQ1AsQ0FBQyxHQUFHMEMsVUFBVUUsS0FBSztRQUNuQyxFQUFFLFVBQU07UUFDTixFQUFFO1FBQ0o7SUFDRjtJQUVBOUMsY0FBY0MsQ0FBQyxHQUFHUCxPQUFPVSxVQUFVLEdBQUc7SUFDdENKLGNBQWNFLENBQUMsR0FBR1IsT0FBT0MsV0FBVyxHQUFHO0lBRXZDLE1BQU1vRCxPQUFPQyxZQUFZUixZQUFZLE9BQU87SUFFNUM5QyxPQUFPdUQsUUFBUSxHQUFHO1FBQ2hCQyxjQUFjSDtRQUNkakU7SUFDQSxzQkFBc0I7SUFDeEI7QUFDRjtBQUVBLCtEQUFlQSxVQUFVQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL3BhZ2UtdWkvaGVyb0NhbnZhcy5qcz9hYWE4Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNhbnZhc0RvdHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgaWYodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyl7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcycpLFxyXG4gICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyksXHJcbiAgICBjb2xvckRvdCA9IFtcclxuICAgICAgJ3JnYigyNTUsIDEsIDEpJyxcclxuICAgICAgJ3JnYigyNTUsIDEsIDEpJyxcclxuICAgICAgJ3JnYigyNTUsIDEsIDEpJyxcclxuICAgICAgJ3JnYigxLCAyNTUsIDEpJyxcclxuICAgICAgJ3JnYigxLCAyNTUsIDEpJyxcclxuICAgIF0sIFxyXG4gICAgY29sb3IgPSAncmdiKDI1NSwgMSwgMSknO1xyXG5cclxuICAvLyBjdHguZ2xvYmFsQWxwaGEgPSAwLjg7XHJcbiAgY2FudmFzLndpZHRoID0gZG9jdW1lbnQuYm9keS5zY3JvbGxXaWR0aDtcclxuICBjYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xyXG4gIGNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuICAvLyBjdHguZmlsbFN0eWxlID0gY29sb3JEb3Q7XHJcbiAgLy8gY3R4LmZpbGxTdHlsZSA9ICdoc2woJyArIDM2MCAqIE1hdGgucmFuZG9tKCkgKyAnLCA1MCUsIDUwJSknO1xyXG4gIGN0eC5saW5lV2lkdGggPSAwLjM7XHJcbiAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XHJcblxyXG4gIGxldCBtb3VzZVBvc2l0aW9uID0ge1xyXG4gICAgeDogKDMwICogY2FudmFzLndpZHRoKSAvIDEwMCxcclxuICAgIHk6ICgzMCAqIGNhbnZhcy5oZWlnaHQpIC8gMTAwLFxyXG4gIH07XHJcblxyXG4gIGNvbnN0IHdpbmRvd1NpemUgPSB3aW5kb3cuaW5uZXJXaWR0aDtcclxuICBsZXQgZG90cztcclxuXHJcbiAgaWYgKHdpbmRvd1NpemUgPiAxNjAwKSB7XHJcbiAgICBkb3RzID0ge1xyXG4gICAgICBuYjogMTAwMCwgLy8gbnVtYmVyIG9mIHBhcnRpY2xlc1xyXG4gICAgICBkaXN0YW5jZTogNzAsIC8vIG1heCBkaXN0YW5jZSBiZXR3ZWVuIHBhcnRpY2xlcyBmb3IgdGhlbSB0byBsaW5rXHJcbiAgICAgIGRfcmFkaXVzOiAzMDAsIC8vIHJhZGl1cyBmcm9tIG1vdXNlIGxvY2F0aW9uIHRoYXQgcGFydGljbGVzIHdpbGwgbGlua1xyXG4gICAgICBhcnJheTogW10sXHJcbiAgICB9O1xyXG4gIH0gZWxzZSBpZiAod2luZG93U2l6ZSA+IDEzMDApIHtcclxuICAgIGRvdHMgPSB7XHJcbiAgICAgIG5iOiA1NzUsXHJcbiAgICAgIGRpc3RhbmNlOiA2MCxcclxuICAgICAgZF9yYWRpdXM6IDI4MCxcclxuICAgICAgYXJyYXk6IFtdLFxyXG4gICAgfTtcclxuICB9IGVsc2UgaWYgKHdpbmRvd1NpemUgPiAxMTAwKSB7XHJcbiAgICBkb3RzID0ge1xyXG4gICAgICBuYjogNTAwLFxyXG4gICAgICBkaXN0YW5jZTogNTUsXHJcbiAgICAgIGRfcmFkaXVzOiAyNTAsXHJcbiAgICAgIGFycmF5OiBbXSxcclxuICAgIH07XHJcbiAgfSBlbHNlIGlmICh3aW5kb3dTaXplID4gODAwKSB7XHJcbiAgICBkb3RzID0ge1xyXG4gICAgICBuYjogMzAwLFxyXG4gICAgICBkaXN0YW5jZTogMCxcclxuICAgICAgZF9yYWRpdXM6IDAsXHJcbiAgICAgIGFycmF5OiBbXSxcclxuICAgIH07XHJcbiAgfSBlbHNlIGlmICh3aW5kb3dTaXplID4gNjAwKSB7XHJcbiAgICBkb3RzID0ge1xyXG4gICAgICBuYjogMjAwLFxyXG4gICAgICBkaXN0YW5jZTogMCxcclxuICAgICAgZF9yYWRpdXM6IDAsXHJcbiAgICAgIGFycmF5OiBbXSxcclxuICAgIH07XHJcbiAgfSBlbHNlIHtcclxuICAgIGRvdHMgPSB7XHJcbiAgICAgIG5iOiAxMDAsXHJcbiAgICAgIGRpc3RhbmNlOiAwLFxyXG4gICAgICBkX3JhZGl1czogMCxcclxuICAgICAgYXJyYXk6IFtdLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIGRlY2lkZWQgdG8gdHVybiBvZmYgY29ubmVjdGluZyBkb3RzIHVuZGVyIDExMDBweFxyXG5cclxuICAvLyB9IGVsc2UgaWYgKHdpbmRvd1NpemUgPiA2NTApIHtcclxuICAvLyAgIGRvdHMgPSB7XHJcbiAgLy8gICAgIG5iOiA0MDAsXHJcbiAgLy8gICAgIGRpc3RhbmNlOiA1MCxcclxuICAvLyAgICAgZF9yYWRpdXM6IDE4NSxcclxuICAvLyAgICAgYXJyYXk6IFtdLFxyXG4gIC8vICAgfTtcclxuICAvLyB9IGVsc2UgaWYgKHdpbmRvd1NpemUgPiA1MDApIHtcclxuICAvLyAgIGRvdHMgPSB7XHJcbiAgLy8gICAgIG5iOiAzMjUsXHJcbiAgLy8gICAgIGRpc3RhbmNlOiA0NSxcclxuICAvLyAgICAgZF9yYWRpdXM6IDE3MCxcclxuICAvLyAgICAgYXJyYXk6IFtdLFxyXG4gIC8vICAgfTtcclxuICAvLyB9IGVsc2Uge1xyXG4gIC8vICAgZG90cyA9IHtcclxuICAvLyAgICAgbmI6IDI3MCxcclxuICAvLyAgICAgZGlzdGFuY2U6IDQ1LFxyXG4gIC8vICAgICBkX3JhZGl1czogMTQwLFxyXG4gIC8vICAgICBhcnJheTogW10sXHJcbiAgLy8gICB9O1xyXG4gIC8vIH1cclxuXHJcbiAgZnVuY3Rpb24gRG90KCkge1xyXG4gICAgdGhpcy54ID0gTWF0aC5yYW5kb20oKSAqIGNhbnZhcy53aWR0aDtcclxuICAgIHRoaXMueSA9IE1hdGgucmFuZG9tKCkgKiBjYW52YXMuaGVpZ2h0O1xyXG5cclxuICAgIHRoaXMudnggPSAtMC41ICsgTWF0aC5yYW5kb20oKTtcclxuICAgIHRoaXMudnkgPSAtMC41ICsgTWF0aC5yYW5kb20oKTtcclxuXHJcbiAgICB0aGlzLnJhZGl1cyA9IE1hdGgucmFuZG9tKCkgKiAxLjU7XHJcblxyXG4gICAgLy8gdGhpcy5jb2xvdXIgPSAnaHNsKCcgKyAzNjAgKiBNYXRoLnJhbmRvbSgpICsgJywgNTAlLCA1MCUpJztcclxuICAgIHRoaXMuY29sb3VyID0gY29sb3JEb3RbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY29sb3JEb3QubGVuZ3RoKV07XHJcbiAgfVxyXG5cclxuICBEb3QucHJvdG90eXBlID0ge1xyXG4gICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgY3R4LmFyYyh0aGlzLngsIHRoaXMueSwgdGhpcy5yYWRpdXMsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XHJcbiAgICAgIC8vIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG91cjtcclxuXHJcbiAgICAgIC8vIG1ha2UgdGhlIGRvdCBjb2xvdXIgZmFkZSBvdXQgdGhlIGZ1cnRoZXIgdGhleSBhcmUgZnJvbSB0aGUgbW91c2VcclxuICAgICAgY29uc3QgZG90RGlzdGFuY2UgPVxyXG4gICAgICAgICgodGhpcy54IC0gbW91c2VQb3NpdGlvbi54KSAqKiAyICsgKHRoaXMueSAtIG1vdXNlUG9zaXRpb24ueSkgKiogMikgKipcclxuICAgICAgICAwLjU7XHJcbiAgICAgIGNvbnN0IGRpc3RhbmNlUmF0aW8gPSBkb3REaXN0YW5jZSAvICh3aW5kb3dTaXplIC8gMS43KTtcclxuXHJcbiAgICAgIC8vIHRoaXMgY2hvcHMgdGhlIGJyYWNrZXQgb2ZmIHRoZSByZ2IgY29sb3VyIGFuZCBhZHMgYW4gb3BhY2l0eVxyXG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5jb2xvdXIuc2xpY2UoMCwgLTEpICsgYCwkezEgLSBkaXN0YW5jZVJhdGlvfSlgO1xyXG5cclxuICAgICAgY3R4LmZpbGwoKTtcclxuICAgIH0sXHJcblxyXG4gICAgYW5pbWF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAvLyBkb250IGFuaW1hdGUgdGhlIGZpcnN0IGRvdCwgaXQgd2lsbCBmb2xsb3cgbW91c2VcclxuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBkb3RzLm5iOyBpKyspIHtcclxuICAgICAgICBjb25zdCBkb3QgPSBkb3RzLmFycmF5W2ldO1xyXG5cclxuICAgICAgICBpZiAoZG90LnkgPCAwIHx8IGRvdC55ID4gY2FudmFzLmhlaWdodCkge1xyXG4gICAgICAgICAgZG90LnZ4ID0gZG90LnZ4O1xyXG4gICAgICAgICAgZG90LnZ5ID0gLWRvdC52eTtcclxuICAgICAgICB9IGVsc2UgaWYgKGRvdC54IDwgMCB8fCBkb3QueCA+IGNhbnZhcy53aWR0aCkge1xyXG4gICAgICAgICAgZG90LnZ4ID0gLWRvdC52eDtcclxuICAgICAgICAgIGRvdC52eSA9IGRvdC52eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZG90LnggKz0gZG90LnZ4O1xyXG4gICAgICAgIGRvdC55ICs9IGRvdC52eTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBsaW5lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG90cy5uYjsgaSsrKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBkb3RzLm5iOyBqKyspIHtcclxuICAgICAgICAgIGNvbnN0IGlfZG90ID0gZG90cy5hcnJheVtpXTtcclxuICAgICAgICAgIGNvbnN0IGpfZG90ID0gZG90cy5hcnJheVtqXTtcclxuXHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIGlfZG90LnggLSBqX2RvdC54IDwgZG90cy5kaXN0YW5jZSAmJlxyXG4gICAgICAgICAgICBpX2RvdC55IC0gal9kb3QueSA8IGRvdHMuZGlzdGFuY2UgJiZcclxuICAgICAgICAgICAgaV9kb3QueCAtIGpfZG90LnggPiAtZG90cy5kaXN0YW5jZSAmJlxyXG4gICAgICAgICAgICBpX2RvdC55IC0gal9kb3QueSA+IC1kb3RzLmRpc3RhbmNlXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgIGlfZG90LnggLSBtb3VzZVBvc2l0aW9uLnggPCBkb3RzLmRfcmFkaXVzICYmXHJcbiAgICAgICAgICAgICAgaV9kb3QueSAtIG1vdXNlUG9zaXRpb24ueSA8IGRvdHMuZF9yYWRpdXMgJiZcclxuICAgICAgICAgICAgICBpX2RvdC54IC0gbW91c2VQb3NpdGlvbi54ID4gLWRvdHMuZF9yYWRpdXMgJiZcclxuICAgICAgICAgICAgICBpX2RvdC55IC0gbW91c2VQb3NpdGlvbi55ID4gLWRvdHMuZF9yYWRpdXNcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICAgIGN0eC5tb3ZlVG8oaV9kb3QueCwgaV9kb3QueSk7XHJcbiAgICAgICAgICAgICAgY3R4LmxpbmVUbyhqX2RvdC54LCBqX2RvdC55KTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gbWFrZSB0aGUgZmlsbCBjb2xvdXIgZmFkZSBvdXQgdGhlIGZ1cnRoZXIgeW91IGFyZSBmcm9tIHRoZSBtb3VzZVxyXG4gICAgICAgICAgICAgIGNvbnN0IGRvdERpc3RhbmNlID1cclxuICAgICAgICAgICAgICAgICgoaV9kb3QueCAtIG1vdXNlUG9zaXRpb24ueCkgKiogMiArXHJcbiAgICAgICAgICAgICAgICAgIChpX2RvdC55IC0gbW91c2VQb3NpdGlvbi55KSAqKiAyKSAqKlxyXG4gICAgICAgICAgICAgICAgMC41O1xyXG4gICAgICAgICAgICAgIGxldCBkaXN0YW5jZVJhdGlvID0gZG90RGlzdGFuY2UgLyBkb3RzLmRfcmFkaXVzO1xyXG5cclxuICAgICAgICAgICAgICAvLyBtYWtlIGl0IHNvIGl0IGRvZXNudCBmYWRlIG91dCBjb21wbGV0ZWx5XHJcbiAgICAgICAgICAgICAgZGlzdGFuY2VSYXRpbyAtPSAwLjM7XHJcbiAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlUmF0aW8gPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBkaXN0YW5jZVJhdGlvID0gMDtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGByZ2IoMjU1LCAwLCAwLCAkezEgLSBkaXN0YW5jZVJhdGlvfSlgO1xyXG5cclxuICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGNyZWF0ZURvdHMoKSB7XHJcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRvdHMubmI7IGkrKykge1xyXG4gICAgICBkb3RzLmFycmF5LnB1c2gobmV3IERvdCgpKTtcclxuICAgICAgdmFyIGRvdCA9IGRvdHMuYXJyYXlbaV07XHJcblxyXG4gICAgICBkb3QuY3JlYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZmlyc3QgZG90IHRvIGJlIHJlbGF0aXZsZXkgbGFyZ2VcclxuICAgIGRvdHMuYXJyYXlbMF0ucmFkaXVzID0gMS41O1xyXG5cclxuICAgIC8vIGZpcnN0IGRvdCB0byBiZSBibHVlXHJcbiAgICBkb3RzLmFycmF5WzBdLmNvbG91ciA9ICcjNTFhMmU5JztcclxuXHJcbiAgICBkb3QubGluZSgpO1xyXG4gICAgZG90LmFuaW1hdGUoKTtcclxuICB9XHJcblxyXG4gIHdpbmRvdy5vbm1vdXNlbW92ZSA9IGZ1bmN0aW9uIChwYXJhbWV0ZXIpIHtcclxuICAgIG1vdXNlUG9zaXRpb24ueCA9IHBhcmFtZXRlci5wYWdlWDtcclxuICAgIG1vdXNlUG9zaXRpb24ueSA9IHBhcmFtZXRlci5wYWdlWTtcclxuXHJcbiAgICAvLyBzb21ldGltZXMgaWYgdGhlIG1vdXNlIGlzIG9mZiBzY3JlZW4gb24gcmVmcmVzaCwgaXQgYnVncyBvdXRcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIHdhbnQgdGhlIGZpcnN0IGRvdCB0byBmb2xsb3cgdGhlIG1vdXNlXHJcbiAgICAgIGRvdHMuYXJyYXlbMF0ueCA9IHBhcmFtZXRlci5wYWdlWDtcclxuICAgICAgZG90cy5hcnJheVswXS55ID0gcGFyYW1ldGVyLnBhZ2VZO1xyXG4gICAgfSBjYXRjaCB7XHJcbiAgICAgIC8vXHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgbW91c2VQb3NpdGlvbi54ID0gd2luZG93LmlubmVyV2lkdGggLyAyO1xyXG4gIG1vdXNlUG9zaXRpb24ueSA9IHdpbmRvdy5pbm5lckhlaWdodCAvIDI7XHJcblxyXG4gIGNvbnN0IGRyYXcgPSBzZXRJbnRlcnZhbChjcmVhdGVEb3RzLCAxMDAwIC8gMzApO1xyXG5cclxuICB3aW5kb3cub25yZXNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBjbGVhckludGVydmFsKGRyYXcpO1xyXG4gICAgY2FudmFzRG90cygpO1xyXG4gICAgLy8gY29uc29sZS5sb2coeWlwcGUpO1xyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjYW52YXNEb3RzO1xyXG4iXSwibmFtZXMiOlsiY2FudmFzRG90cyIsImRvY3VtZW50IiwiY2FudmFzIiwicXVlcnlTZWxlY3RvciIsImN0eCIsImdldENvbnRleHQiLCJjb2xvckRvdCIsImNvbG9yIiwid2lkdGgiLCJib2R5Iiwic2Nyb2xsV2lkdGgiLCJoZWlnaHQiLCJ3aW5kb3ciLCJpbm5lckhlaWdodCIsInN0eWxlIiwiZGlzcGxheSIsImxpbmVXaWR0aCIsInN0cm9rZVN0eWxlIiwibW91c2VQb3NpdGlvbiIsIngiLCJ5Iiwid2luZG93U2l6ZSIsImlubmVyV2lkdGgiLCJkb3RzIiwibmIiLCJkaXN0YW5jZSIsImRfcmFkaXVzIiwiYXJyYXkiLCJEb3QiLCJNYXRoIiwicmFuZG9tIiwidngiLCJ2eSIsInJhZGl1cyIsImNvbG91ciIsImZsb29yIiwibGVuZ3RoIiwicHJvdG90eXBlIiwiY3JlYXRlIiwiYmVnaW5QYXRoIiwiYXJjIiwiUEkiLCJkb3REaXN0YW5jZSIsImRpc3RhbmNlUmF0aW8iLCJmaWxsU3R5bGUiLCJzbGljZSIsImZpbGwiLCJhbmltYXRlIiwiaSIsImRvdCIsImxpbmUiLCJqIiwiaV9kb3QiLCJqX2RvdCIsIm1vdmVUbyIsImxpbmVUbyIsInN0cm9rZSIsImNsb3NlUGF0aCIsImNyZWF0ZURvdHMiLCJjbGVhclJlY3QiLCJwdXNoIiwib25tb3VzZW1vdmUiLCJwYXJhbWV0ZXIiLCJwYWdlWCIsInBhZ2VZIiwiZHJhdyIsInNldEludGVydmFsIiwib25yZXNpemUiLCJjbGVhckludGVydmFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/page-ui/heroCanvas.js\n"));

/***/ })

});